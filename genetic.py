from __future__ import division
import sys
from PIL import Image
import copy
import math
import time
import random


'''
These variables are determined at runtime and should not be changed or mutated by you
'''
start = (0, 0)  # a single (x,y) tuple, representing the start position of the search algorithm
end = (0, 0)  # a single (x,y) tuple, representing the end position of the search algorithm
difficulty = ""  # a string reference to the original import file

'''
These variables determine display coler, and can be changed by you, I guess
'''
GREEN = (0, 255, 0)
PURPLE = (127, 0, 255)
BLUE = (0, 0, 255)

'''
These variables are determined and filled algorithmically, and are expected (and required) be mutated by you
'''
path = []  # an ordered list of (x,y) tuples, representing the path to traverse from start-->goal

A = 50 #global constants
B = 100
C = -10

# performs genetic search of area with goal of exploring all free nodes
def search(map, size):
    """
    :param map: A '1-concept' PIL PixelAccess object to be searched. (basically a 2d boolean array)
    """

    # 1 is unoccupied (white); 0 is occupied (black)
    print ("pixel value at start point ", map[start[0], start[1]])
    print ("pixel value at end point ", map[end[0], end[1]])

    start1 = time.clock() # timer

    # Begin
    Ps = start #start position
    Pe = end #end position

    minipath = []  # mini-path consisting of (x,y) pairs of length=path_size
    path_size = 5  # size of mini-path as determined by sensor range
    nbr_paths = 28
    count = 0

    #Dist = []  #total distance of mini-path by Eucledean
    #Free = []  #number of consecutive unclean cells in mini-path
    clean = []  #global path of cleaned (x,y) pairs
    node = Ps #current position of robot

    cfree,cobs = nodegraph(map,size)
    cleaned = []
    print ("Free Nodes in Map: ", len(cfree))
    print ("Obstacle Nodes in Map: ", len(cobs))
    print ("Total Nodes in Map: ", len(cfree)+len(cobs))

    # Initialization
    # Create 8 random minipaths from start point to seed population
    minipath = get_minipaths(map, size, node, path_size, 8)

    # Genetic Motion Planner
    while (count < len(cfree)): #(count != 1500): # and (Pe not in clean):
        count += 1
        print("# OF GENERATIONS>>", count)

        # Selection
        # Select 2 minipaths for further exploration
        # Get fitness score of all minipaths
        fitpath = []
        for i in range(0, len(minipath)):
            fpath = minipath[i]
            fitpath.append(fitness(fpath, clean))
        #print("fitpath:", fitpath)

        # Get two fittest paths
        f1 = fitpath.index(max(fitpath))
        parent1 = minipath[f1]
        del minipath[f1]
        del fitpath[f1]
        f2 = fitpath.index(max(fitpath))
        parent2 = minipath[f2]
        del minipath[f2]
        del fitpath[f2]
        #print("parent1", parent1)
        #print("parent2", parent2)

        # 50% chance of Crossover
        if random.randint(0, 1) == 1:
            # Crossover
            child1, child2 = crossover(parent1, parent2)
        else:
            child1 = parent1
            child2 = parent2
        # print("child1", child1)
        # print("child2", child2)

        # 50% chance of Mutation
        if random.randint(0, 1) == 1:
            # Mutation
            child1 = mutation(child1, map, size)
            child2 = mutation(child2, map, size)
        # print("child1", child1)
        # print("child2", child2)

        # Add fittest parent to global route
        if not (parent1 in clean):
            clean.extend(parent1)

        #print('Clean=', clean)
        node = clean[-1]  # update current position of robot
        #print('Node=', node)
        minipath = []
        minipath = get_minipaths(map, size, node, path_size, nbr_paths)

        minipath.append(child1)
        minipath.append(child2)
        #print("minipath", minipath)

        #cleaned = [x for x in cfree if x in clean]  # list of visited nodes

    path.extend(clean)
    #print(path)
    visited = [x for x in cfree if x in path] #list of visited nodes
    print ("Number of Nodes generated by Genetic: ", len(path))
    print ("Number of unique Nodes visited by Genetic: ", len(visited))
    print ("Time in sec taken for Genetic: ", "{0:.2f}".format(time.clock() - start1))
    print ("Percentage of Coverage for Genetic: ", "{:.2f}%".format((len(visited)/len(cfree))*100))
    visualize_search("out.png")  # see what your search has wrought (and maybe save your results)


# function that creates node graph of all free and obs spaces in workspace
def nodegraph(map,size):
    cfree = []
    cobs = []
    for i in range(0,size[0]):
        for j in range(0,size[1]):
            if (map[i, j] == 1 or map[i, j] == (255,255,255)):
                cfree.append((i,j))
            else:
                cobs.append((i,j))
    return cfree, cobs


# function that returns all unique minipaths originating from a node
def get_minipaths(map,size,node,path_size,nbr_paths):
    minipaths = []  # array of all minipaths
    nbrpaths = nbr_paths # max number of efficient paths
    while len(minipaths) < nbrpaths:
        mpath = []  # array of current minipath
        mpath.append(node)
        while len(mpath) < path_size:  # append neighbors to node until equal to minipath size
            succ = successors(map, size, mpath[-1])  # get neighbors of node
            #print("successors:", succ)
            #print(mpath)
            next = [x for x in succ if x not in mpath] #delete successors that are already in mpath
            #print(next)
            if next == []:  # new minipaths not possible
                nbrpaths = 0
                break
            gene = random.choice(next)  # select random neighbor
            #print(gene)
            mpath.append(gene)
            #print("mpath:", mpath)
        if (len(mpath) == path_size) and not (mpath in minipaths):  # validate minipath size and uniqueness and add to list
            minipaths.append(mpath)
            #print("minipaths:",minipaths)
        else:
            nbrpaths -= 1
            #print(nbrpaths)

    return minipaths


# assigns a fitness score for each minipath
# fitness is weighted based on # of unclean nodes first,
#   consecutive unclean nodes second, and distance from nodes third
def fitness(ipath,cleaned):
    #ipath is a minipath of length=path_size
    #cleaned is an array of visited nodes
    Dist = 0
    Free = 0
    Distc = 0
    #print("ipath", ipath)
    for j in range(len(ipath)-1):
        #print(j)
        #print(ipath[j])
        Dist += 1 #eucledean(ipath[j],ipath[j+1]) = 1
        #print (cleaned)
        #print(ipath[j+1])
        if not (ipath[j+1] in cleaned):
            Free = Free + 1
            #print (Free)
            Distc += abs((ipath[0][0] - ipath[j+1][0]) + (ipath[0][1] - ipath[j+1][1]))

    F = A*Dist + B*Free + C*Distc #+ eucledean(start, ipath[0])
    return F


# swaps genes between two minipaths at random intersection
def crossover(parent1,parent2):
    #parents are mini-paths of length=path_size
    #single crossover point chosen where valid
    child1 = []
    child2 = []
    for i in range(len(parent1)):
        if (i != 0) and (parent1[i] == parent2[i]):
            #found crossover point
            child1 = parent1[0:i]
            child1.extend(parent2[i:])

            child2 = parent2[0:i]
            child2.extend(parent1[i:])

            return child1, child2

    return parent1, parent2


# mutates a minipath by 1 gene based on random probability
def mutation(child,map,size):
    #single gene is selected at random
    point = random.randint(0, len(child)-1)
    #print("child", child)
    #find neighbors of random gene
    neighbors = successors(map,size,child[point])
    precedents = []
    #sort out which neighbors are not already in child
    for i in neighbors:
        if i not in child:
            if point == 0: #edge case
                if eucledean(i,child[point+1]) == math.sqrt(2):
                    precedents.append(i)
            elif point == (len(child)-1): #edge case
                if eucledean(i,child[point-1]) == math.sqrt(2):
                    precedents.append(i)
            else:
                precedents.append(i)

    mutchild = child
    #random precedent selected
    if precedents:
        xpoint = random.randint(0, len(precedents)-1)
        mutchild[point] = precedents[xpoint] #mutate random gene with new gene
        #print ("mutantchild", child)
    return (mutchild)


# computes eucledean distance between two nodes
def eucledean(a, b):
    # Eucledean distance
    #print("a=", a, "b=", b)
    dist = abs(math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2))
    if dist > 0:
        return dist
    else:
        return 0


# function to find neighbours of a given point (child nodes)
def successors(map, size, v):
    #print("v=", v)
    x = v[0]
    y = v[1]
    grid = size[0];
    points = []
    a = b = c = d = True

    # edge conditions
    if x < 1:
        a = False
    if x > grid - 2:
        b = False
    if y < 1:
        c = False
    if y > grid - 2:
        d = False

    # this is how priorities are set (order matters here)
    if b and (map[x + 1, y] == 1 or map[x + 1, y] == (255,255,255)):
        points.append((x + 1, y))

    if d and (map[x, y + 1] == 1 or map[x, y + 1] == (255,255,255)):
        points.append((x, y + 1))

    if c and (map[x, y - 1] == 1 or map[x, y - 1] == (255,255,255)):
        points.append((x, y - 1))

    if a and (map[x - 1, y] == 1 or map[x - 1, y] == (255,255,255)):
        points.append((x - 1, y))

    return points


# displays input image with route overlay
def visualize_search(save_file="do_not_save.png"):
    """
    :param save_file: (optional) filename to save image to (no filename given means no save file)
    """
    im = Image.open(difficulty).convert("RGB")
    pixel_access = im.load()

    # draw path pixels
    for index, pixel in enumerate(path):
        if index % 2 == 0:
            pixel_access[pixel[0], pixel[1]] = BLUE
        else:
            pixel_access[pixel[0], pixel[1]] = PURPLE

    # draw start and end pixels
    pixel_access[start[0], start[1]] = GREEN
    pixel_access[end[0], end[1]] = GREEN

    # display and (maybe) save results
    im.show()
    if (save_file != "do_not_save.png"):
        im.save(save_file)

    im.close()


# run-time function: reads input image and starts search
if __name__ == "__main__":
    # Throw Errors && Such
    # global difficulty, start, end
    assert sys.version_info[0] == 2  # require python 2 (instead of python 3)
    assert len(sys.argv) == 2, "Incorrect Number of arguments"  # require difficulty input

    # Parse input arguments
    function_name = str(sys.argv[0])
    difficulty = str(sys.argv[1])
    print "running " + function_name + " with " + difficulty + " difficulty."

    # Hard code start and end positions of search for each difficulty level
    if difficulty == "custom.gif":
        start = (6, 50)
        end = (155, 6)
    elif difficulty == "Test_grid.jpg":
        start = (0, 0)
        end = (99, 99)
    elif difficulty == "test1.gif":
        start = (0, 0)
        end = (569, 569)
    elif difficulty == "test2.gif":
        start = (0, 0)
        end = (239, 239)
    elif difficulty == "test3.gif":
        start = (0, 0)
        end = (139, 139)
    else:
        assert False, "Incorrect difficulty level provided"

    # Perform search on given image
    im = Image.open(difficulty)
    sized = im.size
    search(im.load(), sized)

